## 原文地址
[前端正则最全知识汇总](https://juejin.im/post/5e8efc266fb9a03c550fdcb9#heading-25)

#### 正则表达式的组成

#### 元字符

* 量词元字符：设置出现的次数
|元字符|含义|
|----------|------|
|*   |零到多次|
|+   | 一到多次|
|？   |零到一次 |
|{n}   |n次     |
|{n,}     | n到多次   |
|{n,m}     | n到m次|

* 特殊元字符：单个或者组合在一起代表特殊的含义

|元字符|含义|
|---------|-------|
| \ |转义字符|
|.|除\n（换行符）之外的任意字符|
|^|以哪一个元字符开头|
|$|以哪个元字符结尾|
|\n|换行符|
|\d|0-9之间的一个数字|
|\D|除0-9之间的一个数字|
|\w|数字、字母、下划线中的任意一个字符|
|\s|一个空白字符（包含空格、制表符、换页符）|
|\t|一个制表符（一个TAB键，四个空格）|
|\b|匹配一个单词的边界|
| x\|y | x或y中的一个字符|
|[xyz]|x或y或z中的一个字符|
|[^xy]|除x和y以为的任意一个字符|
|[a-z]|指定a-z这个范围的任意字符|
|[^a-z]|上一个的取反“非”|
|()|正则中的分组符号|
|(?:)|只匹配不捕获|
|(?=)|正向预查|
|(?!)|反向预查|

* 普通元字符：代表本身含义的
	/name/次正则就是去匹配字符串中的‘name’
	
#### 修饰符：放在正则表达式的外面/j/g

|修饰符|含义|
|--------|--------|
|i(ignoreCase)|忽略大小学匹配|
|m(multiline)|可以进行可多行匹配|
|g(global)|全局匹配|
|u(Unicode)|用来正确处理大于\uFFF的Unicode字符|
|y(sticky)|粘连|
|s(dotAll)|让‘.’能匹配任意字符，包含\n\r|

#### 常用元字符的详解

####  ^  $

* ^以什么元字符开始
* $以什么元字符结尾
* ^/$ 两个都不加匹配的是：字符串中包含符合规则的内容即可
* ^/$ 两个都加匹配的事：字符串只能是和规则一致的内容

```js
		//匹配的是:以数字开头的字符串
		let reg = /^\d/;
		reg.test('name') //false
		reg.test('2020name') //true
		reg.test('name2020') //false
		
		//匹配的是:是数字结尾的字符串
		let reg = /\d$/;
		
		// ^/$两个都不加匹配的事：字符串中包含符合规则的内容即可
		let reg1 = /\d/;
		reg1.test('as2'); //true
		// ^/$ 两个都加匹配的是:字符串只能和规则一致的内容
		let reg2 = /^\d$/
```


 #### \

*	转义字符，他可以吧没有意义的专为有意义的，也可以吧有意义的变为没有意义的

```js
	// '.'是代表除换行符之外的任意字符，而不是小数点
	let reg = /^2.3$/;
	reg.test('2.3') //true
	reg.test('2@3') //true
	reg.get('23') //false
	
	//如果需要把‘.’变为一个普通的小数点
	let reg = /^2\.3$/
	reg.test('2.3') //true
	reg.test('2@3') //false
```

####  x|y

*	x或y：直接x|y会存在优先级问题，一般配合小括号进行分组使用，因为小括号改变处理的优先级 => 小括号：分组

```js
	//匹配的是：以18开头或以29结尾的都可以，以1开头以9结尾，8或2都可以没所以不加括号理解都可以
	//以下的匹配结果都为true
	let reg = /^18|29$/;
	console.log(reg.test('18'));
    console.log(reg.test('29'));
    console.log(reg.test('129'));
    console.log(reg.test('189'));
    console.log(reg.test('1829'));
    console.log(reg.test('182'));
	//以上不加括号我们可以有很多理解方式都是对的，但是我们加上括号，就不可能像上面那样理解了
	//匹配的事：18或者29中的一个，其余都是fasle
	let reg = /^(18|29)$/;
    console.log(reg.test('18'));
    console.log(reg.test('29'));
    console.log(reg.test('129'));
    console.log(reg.test('189'));
```

#### []

* 中括号中出现的字符【一般】都表示其本身的意义
* \d 在中括号里面的含义任然是0-9.这个没有消磁
* 【18】:代表是1或者8中的任意一个
* 【10-29】：代表的是1或者9或者0-2

```js
	//下面的‘.’就是小数点的意思
	let reg = /^[.]+$/;
	
	//匹配的含义是:只能是@或者+的
	let reg = /^[@+]$/;
	
	//匹配的含义:\d还是代表0-9
	let reg = /^[\d]$/;
	
	//匹配的含义是：1或者8
	let reg = /^[18]$/;
	
	//匹配的含义是:1或者0-2或者9
	let reg = /^[10-29]$/;
	
	//匹配的含义是：1或者0-2或者9或者‘C’或者‘）’
	let reg = /^[(10-29)]$/;
```

#### {n,m}

* 它是代表前面的元字符出现n到m次

```js
	//这个正则匹配的是数字出现2到4次即可，明显第三个超出了，应该返回false，但结果却是true，但是叫上^$，就不一样了
	let reg = /\d{2,4}/;
	reg.test('1');  //false
    reg.test('14'); //true
    reg.test('123456'); //true
  	//加上^$之后的结果：这个就代表只能2-4位数字，超过就多余，而上一个匹配的是只有字符串中出现2-4次即可。
  	let reg = /^\d{2,4}$/;
  	reg.test('1'); //false
    reg.test('14'); //true
    reg.test('123456'); //false
```

#### 分组作用

* 1.就是改变默认的优先级
* 2.分组捕获；
* 3.分组引用

```js
	//第一个作用：提升优先感，reg1可以匹配的比reg2的多，这个作用在上面已经说过了，这里就不再详细写
	let reg1 = /^18|29$/;
	let reg2 = /^(18|29)$/;
	
	//第二个作用：使用exec捕获的时候不仅可以得到整个大正则的结果，也会分别拿到每一个分组内的
	
	//第三个作用：第一位是a-z的字母，分组1：第二位是a-z的字母，分组2：第三位\2是和第二个分组出现一模一样的内容
	
	let reg1 = /^([a-z])([a-z])\2\1$/
```

#### 问号在正则中的五大作用

* 1.问号左边是非量词元字符：本身代表量词元字符，出现零到一次；
* 2.问号左边是量词元字符：取消捕获时候的贪婪性；
* 3.（？：）：只匹配不捕获；
* 4.（？=）：正向预查；
* 5.（？!）负向预查

#### 验证手机号

规则：
* 11位
* 第一位数字1
* 第二位数字3-9的任意一位

```js
	let reg = /^1[3-9]\d{9}$/;
```

#### 验证是否为有效数字

规则：
+  开头可以有+ -
+  整数位
	* 如果是一位数可以是0-9任意数
    - 如果是多位数，首位不可以是0；
+ 小数位：如果是小数位，那么小数位后面至少有一位数字，也可以没有小数位

```js
	let reg = /^[+-]?(\d|[1-9]\d+)(\.\d+)?$/;
```

#### 验证密码

* 6-16位组成
* 必须由数字字母组成

```js
	let reg = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[\d(a-z)(A-Z)]{6,16}$/
```

#### 验证真实姓名

* 必须是汉字
* 名字长度2-10位
* 可能有译名：汉字

```js
	let reg = /^[\u4E00-\u9FA5]{2,10}(·[\u4E00-\u9FA5]{2,10})?$/
```

#### 验证邮箱

* 邮箱的名字以‘数字字母下划线-.’ 几个部分组成，但是-/.不能连续出现也不能作为开头\w+((-\w+)|(.\w+))*;

* @后面可以加数字字母，可以出现多位@[A-Za-z0-9]+ ；
* 对@后面名字的补充：多域名.com.cn;企业域名（.|-）[A-Za-z0-9]+)*
* .com/.cn 等域名 .[A-Za-z)-9]+

```js
	let reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/
```
#### 验证身份证号
* 18位
* 最后一位是数字或者X
* 前6位是省市县
* 后四位是年
* 后两位是月01-12
* 后两位是日01-31
* 最后四位
* 最后一位：X或者数字
* 倒数第二位：偶数：女 奇数：男 小括号分组的作用：分组捕获，不仅可以把大正则匹配信息捕获到，还可以单独捕获获得每个小分组的内容

```js	
	let reg = /^([1-9]\d{5})((19|20)\d{2})(0[1-9]|10|11|12)(0[1-9]|[1-2]\d|30|31)\d{3}(\d|x)$/i
```
