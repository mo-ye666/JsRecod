## 1.事务

#### 1.1 事务特点
1. 原子性：事务是一个原子操作单元，要么全部执行成功，要么全部回滚到事务开始前的状态。如果事务中的任何一部分
操作失败，整个事务将被回滚，数据库状态不会受到部分操作的影响。
2. 一致性：事务执行前后，数据库必须保持一致的状态，即遵循预定义的业务规则和完整性约束。事务中的操作应确保数据
的完整性和业务逻辑的正确性。
3. 隔离性：事务的执行应该与其他并发事务相应隔离，互不干扰。并发事务之间应该感知不到其他事务的存在，每个事务应该
看到一个独立的、一致的数据库状态。隔离级别定义了多个事务之间的隔离程度，如读未提交、读提交、可重复读和串行化。
4. 持久性：一旦事务提交，其结果应该永久保存在数据库中，即使发生系统故障或重启。数据库系统应该能够将事务的提交
记录持久的写入磁盘，以确保数据的持久性。

#### 1.2 事务级别
1. 读未提交（Read Uncommitted）：
    * 最低的隔离级别，事务中的修改可以被其他事务读取，即一个事务可以读取另一个事务尚未提交的数据
    * 存在脏读（Dirty Read）问题，即读取到其他事务修改但未提交的数据，可能导致不一致的查询结果。

2. 读提交（Read Committed）:
    * 默认的隔离级别，事务中的修改只能在提交后才能被其他事务读取，即一个事物只能读取另一个事务已经提交的数据。
    * 避免了脏读问题，但存在不可重复读的问题，即在同一个事务中，多次读取同一数据会得到不同的结果。

3. 可重复读（Repeatable Read）:
   * 在同一个事务中，多次读取同一数据会得到一致的结果。其他事务只能读取已经提交的数据，不能读取正则进行的事务中的数据。
   * 避免不重复读的问题，但存在幻读的问题，即在同一个事务中，多次查询同一范围的数据可能会得到不同的结果。
  
4. 串行化（Serializable）:
    * 最高的隔离级别，所有事务顺序依次执行，每个事务看到的数据都是一致的。事务之间完全隔离，避免了脏读、不可重复读和幻读问题。
    * 由于事务串行执行，可能导致并发性能降低，因此一般情况下较少使用。

死锁（Deadlock）
死锁是指两个或多个事务在执行过程中因互相等待对方持有的资源而无法继续执行的情况，导致这些事务永远无法完成。

## 2.数据类型

1. 整数类型：
    * INT（整数）：表示正负整数，通常占用4字节。
    * SMLLINT（小整数）：表示较小范围的整数，通常占用2字节。
    * BIGINT（大整数）：表示较大范围的整数，通常占用8字节。

2. 浮点数类型：
    * FLOAT（浮点数）：表示单精度浮点数，通常占用4字节。
    * DOUBLE（双精度浮点数）：表示双精度浮点数，通常占用8字节。

3. 字符串类型：
    * CHAR（定长字符串）：表示固定长度的字符串，最大长度需要指定。
    * VARCHAR（可变长度字符串）：表示可变长度的字符串，最大长度需要指定。
    * TEXT（文本类型）：表示可变长度的大文本字符串。

4.  日期和时间类型：
    * DATE（日期）：表示日期，格式为YYYY-MM-DD
    * TIME(时间)：格式为HH：MM：SS
    * DATIME（日期时间）：格式为：YYYY-MM-DD HH：MM：SS

5. 布尔类型：
    * BOOLEAM（布尔值）：表示真（true）或假（False）的值。

6. 二进制类型：
    * BLOB（二进制大对象）：表示二进制数据，如图象，音频。
    * BINARY（定长二进制）：表示固定长度的二进制数据。

7. 其他类型：
    * DECIMAL（十进制）：表示精确的十进制数，需要指定总位数和小数位数。
    * ENUM（枚举类型）：表示可选的枚举值集合。
    * JSON（JSON数据）：表示存储和操作JSON格式的数据。

## 3. MySQL索引和SQL调优
索引（index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。

#### 3.1 索引类型
   * B-Treee索引：是MySQL最常见的索引类型，适用于等值查询、范围查询和排序操作
   * 哈希索引：适用于精确匹配查询，但不支持范围查询和排序操作。
   * 全文索引：用于全文搜索，适用于对文本内容进行关键词搜索的场景。

#### 3.2 索引原理
通过不断的缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过
同一种查找方法来锁定数据。

索引虽然加快了查询速度，但索引也是有代价的：索引的本身要消耗储存空间，同事索引会加重插入、删除和修改记录时的负担，另外，mySQL在运行时也要消耗
资源维护索引。

#### 3.3 建立索引的常用技巧
1. 最左前缀匹配规则，mySQL会一直向右匹配知道遇到查询（>,<,between,like）就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4如果建立（a,b,c,d）顺序的索引，
d是用不到索引的，如果建立（a,b,d,c）的索引则都可以用到，a,b,d的顺序可以任意调整。

2. =和in可以乱序，比如a=1 and b=2 and c=3建立（a,b,c）索引可以任意顺序，mySQL的查询优化器会帮你优化成索引可识别的形式。

3. 尽量选择区分度高的列作为索引，区分度的公示是count（distinct col）/count(*),表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1 ，而一些状态
、性别字段可能在大数据前区分度就是0。

4. 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = "2014-05-29"就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，
需要把所有元素都应用函数才能比较，显然成本太大。所有语句应该写成create_time = unix_timestamp('2014-05-29');

5. 尽量的扩招索引，不要新建索引，比如表中已经有a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。

#### 3.4 慢查询优化基本步骤
0. 先运行看看是否真的很慢。
1. where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高。
2. explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
3. order by limit形式的SQL语句让排序的表优先查
4. 了解业务方使用场景。
5. 加索引时参照建索引的几大原则。

#### 3.5 执行计划explain
explain各个字段的含义
1. id:表示SQL执行的顺序的标识，SQL从大到小执行。
2. select_type:表示查询中每个select子句的类型。
3. table：显示这一行的数据是关于那张表的，有时不是真实的表名字。
4. type: 表示MySQL在表中找到所需行的方式，又称“访问类型”。常用的类型有：ALL，index,range,ref,eq_ref,const,system,NULL(从左到右，性能从差到好)
5. possible_keys:指出MySQL能使用那个索引在表中找到记录，查询涉及到字段上若存在索引，则该索引将被列出，但不一定被查询使用。
6. key:key列显示MySQL实际决定使用的键（索引），如果没有索引，键是NULL。
7. key_len:表示索引中使用的字节数，可通过改列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是
通过表内检索出的）
8. ref：表示上述表的连接匹配条件，即那些列或常量被用于查找索引列上的值。
9. rows：表示mySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数，理论上行数越少，查询性能越好。
10. EXtra：该列包含MySQL解决查询的详细信息。

explain的特性
* explain不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况。
* explain不会考虑各种Cache
* explain不能显示MySQL在执行查询时所做的优化工作
* 部分统计信息是估算的，并非精确值
* explain只能解释SELECT操作。

## 练习
Employee 表：

| Column Name | Type |
| ----------- | ---- |
| id          | int  |
| salary      | int  |

在 SQL 中，id 是这个表的主键。
表的每一行包含员工的工资信息。
 

查询并返回 Employee 表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 null(Pandas 则返回 None) 。

```SQL
select max(salary) as  SecondHighestSalary 
from Employee 
where salary != (
    select max(salary) from Employee 
)
```

表: Employee
| Column Name  | Type    |
| ------------ | ------- |
| id           | int     |
| name         | varchar |
| salary       | int     |
| departmentId | int     |

id 是该表的主键列(具有唯一值的列)。
departmentId 是 Department 表中 ID 的外键（reference 列）。
该表的每一行都表示员工的ID、姓名和工资。它还包含了他们部门的ID。
 

表: Department
| Column Name | Type    |
| ----------- | ------- |
| id          | int     |
| name        | varchar |

id 是该表的主键列(具有唯一值的列)。
该表的每一行表示部门ID和部门名。
公司的主管们感兴趣的是公司每个部门中谁赚的钱最多。一个部门的 高收入者 是指一个员工的工资在该部门的 不同 工资中 排名前三 。
编写解决方案，找出每个部门中 收入高的员工 。

```SQL
    SELECT
        d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary
    FROM
        Employee e1
            JOIN
        Department d ON e1.DepartmentId = d.Id
    WHERE
    3 > (SELECT
            COUNT(DISTINCT e2.Salary)
        FROM
            Employee e2
        WHERE
            e2.Salary > e1.Salary
                AND e1.DepartmentId = e2.DepartmentId
        )
```




